@page "/"
@using ChatX_Blazor.Data;
@using ChatX_Blazor.Models;
@using Microsoft.AspNetCore.SignalR.Client;
@inject NavigationManager NavigationManager;
@implements IAsyncDisposable



<label class="username">
    Username: <input @bind="usernameInput" type="text"/>
</label>
<div class="container">
    <img src="/MicrosoftTeams-image.png" />
    @if (!IsConnected)
    {
        <p>Connecting to server...</p>
    }
    else
    {
        <div class="list-container">
            @foreach (var message in localMessages)
            {
                if (usernameInput == message.Sender)
                {
                    <div id="userMsg">
                        <p><span class="username">@usernameInput</span> @message.Content</p>
                        <button @onclick:preventDefault="true" @onclick="() => DeleteMessageAsync(message.Id)">Delete</button>
                    </div>
                }
                else
                {
                    <div id="msg">
                        <p><span class="username">@message.Sender</span>@message.Content</p>
                    </div>    
                } 
            }
        </div>
        @if (usersCurrentlyTyping.Count > 0)
        {
            @if (usersCurrentlyTyping.Count == 1)
            {
                <p class="currently-typing">@usersCurrentlyTyping[0] is typing...</p>
            }
            else
            {
                <p class="currently-typing">Several people are typing...</p>
            }
            
        }
        <div id="input-container">
            <form >
                <input class="messageInput" type="text" disabled="@string.IsNullOrWhiteSpace(usernameInput)" @oninput="CurrentlyTypingAsync" @bind="messageInput" />
                <button class="buttons" disabled="@string.IsNullOrWhiteSpace(usernameInput)" @onclick:preventDefault="true" @onclick="SendMessageAsync">Send</button>
            </form>
        </div>
    }
</div>

@code {
    // Data variables in Vue
    private HubConnection? hubConnection;
    private List<Message> localMessages = new();
    private string? messageInput;
    private string? usernameInput;
    private List<string> usersCurrentlyTyping = new();
    private CancellationTokenSource? typingTimeoutToken;
    private bool isTyping = false;
    private const int timeoutDuration = 2500;

    // connect() method in Vue
    protected override async Task OnInitializedAsync()
    {
        hubConnection = new HubConnectionBuilder()
        .WithUrl(NavigationManager.ToAbsoluteUri("/chatHub"))
        .Build();

        hubConnection.On<List<Message>>("ReceiveMessageHistory", (messages) =>
        {
            localMessages = messages;
            // Needs to be called in order to inform Blazor that localMessages has been changed
            InvokeAsync(StateHasChanged);
        });

        hubConnection.On<Message>("ReceiveMessage", (message) =>
        {
            localMessages.Add(message);
            InvokeAsync(StateHasChanged);
        });

        hubConnection.On<List<string>>("CurrentlyTyping", (usersTyping) =>
        {
            usersCurrentlyTyping = usersTyping;
            InvokeAsync(StateHasChanged);
        });

        hubConnection.On<int>("DeleteMessage", (id) =>
        {
            Message? toRemove = localMessages.Where(m => m.Id == id).SingleOrDefault();

            if (toRemove is not null)
            {
                localMessages.Remove(toRemove);
                InvokeAsync(StateHasChanged);
            }
        });

        await hubConnection.StartAsync();
        await LoadPreviousMessagesAsync();
    }

    // loadPreviousMessages() method in Vue
    private async Task LoadPreviousMessagesAsync()
    {
        if (hubConnection is not null)
        {
            await hubConnection.SendAsync("LoadPreviousMessages");
        }
    }

    // sendMessage() method in Vue
    private async Task SendMessageAsync()
    {
        if (hubConnection is not null)
        {
            if (!string.IsNullOrWhiteSpace(messageInput) && !string.IsNullOrWhiteSpace(usernameInput))
            {
                await hubConnection.SendAsync("SendMessage", usernameInput, messageInput);
                messageInput = string.Empty;
            }
        }
    }

    // deleteMessage() method in Vue
    private async Task DeleteMessageAsync(int id)
    {
        if(hubConnection != null)
        {
            await hubConnection.SendAsync("DeleteMessage", id);
        }
    }

    // currentlyTyping() method in Vue
    private async Task CurrentlyTypingAsync()
    {
        typingTimeoutToken?.Cancel();

        if (!isTyping)
        {
            if (hubConnection is not null)
            {
                await hubConnection.SendAsync("UserTyping", usernameInput, true);
                isTyping = true;
            }
        }

        typingTimeoutToken = new CancellationTokenSource();
        var timeoutTask = Task.Delay(timeoutDuration, typingTimeoutToken.Token);

        await timeoutTask;
        if (!timeoutTask.IsCanceled)
        {
            if (hubConnection is not null)
            {
                await hubConnection.SendAsync("UserTyping", usernameInput, false);
                isTyping = false;
            }
        }
    }

    public bool IsConnected => hubConnection?.State == HubConnectionState.Connected;

    // Disposes of SignalR resources when client disconnects
    public async ValueTask DisposeAsync()
    {
        if (hubConnection is not null)
        {
            await hubConnection.DisposeAsync();
        }
    }
}